# AUTOGENERATED â€” conditional EventBridge statement to avoid empty ArnEquals
data "aws_caller_identity" "current" {}
data "aws_region" "current" {}

data "aws_iam_policy_document" "sns" {
  # EventBridge statement only when rule ARNs are provided
  dynamic "statement" {
    for_each = length(var.eventbridge_rule_arns) > 0 ? [1] : []
    content {
      sid       = "AllowEventBridge"
      effect    = "Allow"
      actions   = ["sns:Publish"]
      resources = [aws_sns_topic.alerts.arn]

      principals {
        type        = "Service"
        identifiers = ["events.amazonaws.com"]
      }

      condition {
        test     = "ArnEquals"
        variable = "aws:SourceArn"
        values   = var.eventbridge_rule_arns
      }

      condition {
        test     = "StringEquals"
        variable = "aws:SourceAccount"
        values   = [data.aws_caller_identity.current.account_id]
      }
    }
  }

  # CloudWatch alarms statement (only when names exist)
  dynamic "statement" {
    for_each = length(var.smoke_alarm_names) > 0 ? [1] : []
    content {
      sid       = "AllowCloudWatchAlarms"
      effect    = "Allow"
      actions   = ["sns:Publish"]
      resources = [aws_sns_topic.alerts.arn]

      principals {
        type        = "Service"
        identifiers = ["cloudwatch.amazonaws.com"]
      }

      condition {
        test     = "ArnEquals"
        variable = "aws:SourceArn"
        values = [
          for n in var.smoke_alarm_names :
          "arn:aws:cloudwatch:${var.region}:${data.aws_caller_identity.current.account_id}:alarm/${n}"
        ]
      }

      condition {
        test     = "StringEquals"
        variable = "aws:SourceAccount"
        values   = [data.aws_caller_identity.current.account_id]
      }
    }
  }
}

resource "aws_sns_topic_policy" "alerts" {
  arn    = aws_sns_topic.alerts.arn
  policy = data.aws_iam_policy_document.sns.json
}
