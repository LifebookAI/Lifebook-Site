      - name: Presign → PUT → GET via CloudFront
        shell: bash
        run: |
          set -euo pipefail
          TS=$(date +%s)
          BODY='{"key":"sources/smoke/pr-'"$GITHUB_RUN_ID"'.txt","contentType":"text/plain","contentDisposition":"inline"}'

          # HMAC(ts.body) with hex key (client = server must match)
          SIG=$(python3 -c "import sys,hmac,hashlib; ts,body,hexkey=sys.argv[1:4]; print(hmac.new(bytes.fromhex(hexkey), f'{ts}.{body}'.encode(), hashlib.sha256).hexdigest())" "$TS" "$BODY" "$PRESIGN_HMAC_SECRET")

          # Call presign and capture both body and status code
          code=$(curl --silent --show-error --fail-with-body \
            -o /tmp/presign.json -w '%{http_code}' \
            -X POST "$PRESIGN_API_BASE/presign" \
            -H "x-api-key: $PRESIGN_API_KEY" \
            -H "x-timestamp: $TS" \
            -H "x-signature: $SIG" \
            -H "content-type: application/json" \
            -d "$BODY" || true)

          echo "presign HTTP=$code"
          # Redact just in case; most APIs return non-secret error text
          sed -e 's/[A-Za-z0-9_]\{24,\}/[redacted]/g' /tmp/presign.json || true

          test "$code" = "200"  # fail the step if not OK

          URL=$(jq -r .url /tmp/presign.json)
          echo "Presign URL obtained: ${URL%%\?*}"

          echo "hello from e2e smoke $GITHUB_RUN_ID" > /tmp/smoke.txt
          curl -sfS -X PUT -T /tmp/smoke.txt "$URL" -H "x-amz-server-side-encryption: AES256"

          KEY=$(python3 -c 'import sys; from urllib.parse import urlparse; p=urlparse(sys.argv[1]).path; print(p.split("/",3)[-1])' "$URL")
          GET_URL="${CF_BASE_URL%/}/$KEY"
          echo "Verifying via CloudFront: $GET_URL"
          curl -sfS "$GET_URL" | tee /tmp/fetched.txt
          grep -q "hello from e2e smoke" /tmp/fetched.txt
